{"version":3,"sources":["regexp.js"],"names":[],"mappings":";;AAAA;;;;AAIA;;;;;;;;AAQA,IAAI,SAAS,IAAI,MAAJ,CAAW,KAAX,EAAkB,GAAlB,CAAb;AACI,SAAS,IAAI,MAAJ,CAAW,MAAX,CAAT;AACA,SAAS,IAAI,MAAJ,CAAW,OAAX,EAAoB,GAApB,CAAT,C,CAAmC;;AAEvC;;;AAGA,OAAO,SAAP,CAAiB,KAAjB;AACA,OAAO,SAAP,CAAiB,OAAjB;AACA,OAAO,SAAP,CAAiB,MAAjB;AACA,OAAO,SAAP,CAAiB,KAAjB;;AAEA;;;;AAIA,IAAI,IAAI,IAAR;AACA,IAAI,MAAJ,CAAW,QAAX,EAAqB,GAArB,EAA0B,IAA1B,CAA+B,cAA/B,E,CAAgD;AAChD,SAAS,IAAT,CAAc,cAAd,E,CAA+B;;AAE/B;;;;;;AAMA,MAAM,IAAN,CAAW,CAAX,E,CAAe;AACf,IAAI,MAAJ,CAAW,KAAX,EAAkB,GAAlB,EAAuB,IAAvB,CAA4B,CAA5B,E,CAAgC;;AAEhC;;;AAGA,SAAS,IAAT,CAAc,GAAd,E,CAAoB;AACpB,IAAI,MAAJ,CAAW,QAAX,EAAqB,GAArB,EAA0B,IAA1B,CAA+B,GAA/B,E,CAAqC;;AAErC;;;;AAIA,OAAO,IAAP,CAAY,CAAZ,E,CAAgB;AAChB,IAAI,MAAJ,CAAW,CAAX,EAAc,GAAd,EAAmB,IAAnB,CAAwB,CAAxB,E,CAA4B;;AAE5B;;;;;;AAMA,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,MAAI,SAAS,KAAK,KAAL,CAAW,IAAI,MAAJ,CAAW,MAAX,EAAmB,GAAnB,CAAX,CAAb;AACA,SAAO,SAAS,OAAO,MAAhB,GAAyB,CAAhC;AACH;AACD,IAAI,MAAJ;AACA,EAAE,MAAF,C,CAAU;AACV,gBAAgB,CAAhB,E,CAAoB;;AAEpB;;;;;AAKA,IAAI,UAAJ;AACA,IAAI,KAAK,KAAT;AACA,IAAI,KAAK,IAAI,MAAJ,CAAW,IAAX,EAAiB,GAAjB,CAAT;;AAEA,GAAG,IAAH,CAAQ,CAAR,E,CAAY;AACZ,GAAG,IAAH,CAAQ,CAAR,E,CAAY;;AAEZ,GAAG,IAAH,CAAQ,CAAR,E,CAAY;AACZ,GAAG,IAAH,CAAQ,CAAR,E,CAAY;;AAEZ;;;;;AAKA,GAAG,SAAH,GAAe,CAAf;AACA,GAAG,IAAH,CAAQ,CAAR,E,CAAY;;AAEZ;;;;AAIA,GAAG,MAAH,C,CAAW;;AAEX;;;;AAIA,GAAG,MAAH,C,CAAW;;AAEX;;;;AAIA,GAAG,KAAH,C,CAAU;;AAEV,SAAS,YAAT,CAAsB,IAAtB,EAA4B;AACxB,SAAO,KAAK,OAAL,CAAa,qCAAb,EAAoD,MAApD,CAAP;AACH","file":"regexp-compiled.js","sourcesContent":["/**\r\n * Created by wangj on 2016/12/11.\r\n */\r\n\r\n/**\r\n * RegExp(str, flag)\r\n * str是匹配字符串或正则表达式\r\n * flag是正则表达式的修饰符\r\n * flag会覆盖str正则表达式的修饰符\r\n * 正则构造函数\r\n * @type {RegExp}\r\n */\r\nvar regexp = new RegExp('xyz', 'i');\r\n    regexp = new RegExp(/xyz/i);\r\n    regexp = new RexExp(/xyz/ig, 'i'); // 等价于regexp = /xyz/i\r\n\r\n/**\r\n * String的方法用到正则的地方\r\n */\r\nString.prototype.match;\r\nString.prototype.replace;\r\nString.prototype.search;\r\nString.prototype.split;\r\n\r\n/**\r\n * u修饰符\r\n * unicode模式，正确处理四字节字符\r\n */\r\nvar s = '𠮷';\r\nnew RegExp(/\\uD83D/, 'u').test('\\uD83D\\uDC2A'); // false\r\n/\\uD83D/.test('\\uD83D\\uDC2A'); //true\r\n\r\n/**\r\n * 点符号\r\n * 匹配除了换行符以外的任意单个字符串\r\n * 不匹配四字节字符\r\n * @type {string}\r\n */\r\n/^.$/.test(s); //false\r\nnew RegExp(/^.$/, 'u').test(s); //true\r\n\r\n/**\r\n * 正则匹配unicode字符时需要加上u修饰符，否则被视为量词\r\n */\r\n/\\u{61}/.test('a'); //false\r\nnew RegExp(/\\u{61}/, 'u').test('a'); //true\r\n\r\n/**\r\n * \\S匹配所有不是空格的字符，不识别四字节字符\r\n * 加上u修饰符才能识别四字节字符\r\n */\r\n/^\\S$/.test(s); // false\r\nnew RegExp(s, 'u').test(s); //true\r\n\r\n/**\r\n * 技巧一\r\n * 字符串长度，匹配四字节字符\r\n * @param text\r\n * @returns {*}\r\n */\r\nfunction codePointLength(text) {\r\n    let result = text.match(new RegExp(/\\s\\S/, 'u'));\r\n    return result ? result.length : 0;\r\n}\r\ns = '𠮷𠮷';\r\ns.length; // 4\r\ncodePointLength(s); //2\r\n\r\n/**\r\n * y修饰符\r\n * 与g修饰符类似，全局匹配，不同的是后一次匹配都是上一次匹配成功的下一个位置\r\n * @type {string}\r\n */\r\ns = 'aaa_aa_a';\r\nvar r1 = /a+/g;\r\nvar r2 = new RegExp(/a+/, 'y');\r\n\r\nr1.exec(s); //\"aaa\"\r\nr2.exec(s); //\"aaa\"\r\n\r\nr1.exec(s); //\"aa\"\r\nr2.exec(s); //null\r\n\r\n/**\r\n * lastIndex属性\r\n * 下一次匹配的字符位置\r\n * @type {number}\r\n */\r\nr2.lastIndex = 0;\r\nr2.exec(s); //\"aaa\"\r\n\r\n/**\r\n * stiky属性\r\n * 是否设置了y修饰符\r\n */\r\nr2.sticky; //true\r\n\r\n/**\r\n * source属性\r\n * 正则表达式的正文\r\n */\r\nr2.source; //\"a+\"\r\n\r\n/**\r\n * flags属性\r\n * 正则表达式的修饰符\r\n */\r\nr2.flags; //y\r\n\r\nfunction escapeRegExp(text) {\r\n    return text.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\r\n}\r\n\r\n\r\n"]}