{"version":3,"sources":["let_const.js"],"names":[],"mappings":";;AAAA;;;;;AAKA,IAAI,IAAI,EAAR;;2BACQ,C;AACJ,IAAE,CAAF,IAAO,YAAW;AACd,YAAQ,GAAR,CAAY,CAAZ;AACH,GAFD;;;AADJ,KAAI,IAAI,IAAI,CAAZ,EAAe,IAAI,EAAnB,EAAuB,GAAvB,EAA4B;AAAA,QAApB,CAAoB;AAI3B;AACD,EAAE,CAAF;;AAEA;;;AAGA,QAAQ,GAAR,CAAY,GAAZ,E,CAAiB;AACjB,QAAQ,GAAR,CAAY,GAAZ,E,CAAiB;;AAEjB,IAAI,MAAM,CAAV;AACA,IAAI,MAAM,CAAV;;AAEA;;;;AAIA;;;;;;;AAOA;;;;AAIA;;;;;;;;;;AAUA;;;AAGA,CAAC,YAAY;AACT,MAAI,MAAM,EAAV;AACH,CAFD;;AAIA;AACI,MAAI,MAAM,EAAV;AACH;;AAED;;;;AAIA;AAAA,MACa,CADb,GACI,SAAS,CAAT,GAAa,CAAE,CADnB;AAEC;;AAED;;;AAGA;AACA,IAAI,IAAJ,EAAU;AAAA,MACG,EADH,GACN,SAAS,EAAT,GAAa,CAAE,CADT;AAET;;AAED;AACA;;;;AAIA;;;;AAIA;;;;;;;AAOA;;;;AAIA,IAAM,KAAK,MAAX;;AAEA;;;AAGA;;;AAGA;AACI,MAAM,MAAM,CAAZ;AACH;;AAED;;;AAGA;;;AAGA;;;;;AAKA;;;;;AAKA;;;AAGA;;;;;AAKA,IAAM,QAAQ,EAAd;AACA,MAAM,IAAN,CAAW,OAAX;AACA,MAAM,MAAN,GAAe,CAAf;AACA;;AAEA;;;AAGA,OAAO,MAAP,CAAc,KAAd;;AAEA;;;;AAIA,IAAI,IAAI,CAAR;AACA,OAAO,CAAP,C,CAAS;;AAET,IAAI,IAAI,CAAR;AACA,OAAO,CAAP,C,CAAS","file":"let_const-compiled.js","sourcesContent":["/**\r\n * let\r\n * 作用块内有效\r\n * @type {Array}\r\n */\r\nvar a = [];\r\nfor(let i = 0; i < 10; i++) {\r\n    a[i] = function() {\r\n        console.log(i);\r\n    }\r\n}\r\na[6]();\r\n\r\n/**\r\n * 不存在变量提升\r\n */\r\nconsole.log(foo);//undefined\r\nconsole.log(bar);//报错ReferenceError\r\n\r\nvar foo = 2;\r\nlet bar = 2;\r\n\r\n/**\r\n * 暂时性死区\r\n * @type {number}\r\n */\r\n/*var tmp = 123;\r\n\r\nif(true) {\r\n    tmp = 'abc';//ReferenceError\r\n    let tmp;\r\n}*/\r\n\r\n/**\r\n * 不允许重复声明\r\n * 以下全部报错\r\n */\r\n/*{\r\n    let a = 10;\r\n    var a = 1;\r\n}\r\n\r\n{\r\n    let a = 10;\r\n    let a = 1;\r\n}*/\r\n\r\n/**\r\n * 块级作用域\r\n */\r\n(function () {\r\n    var tmp = '';\r\n})();\r\n\r\n{\r\n    let tmp = '';\r\n}\r\n\r\n/**\r\n * 块级作用域可以声明函数\r\n * 类似于let，块级作用域外不可访问\r\n */\r\n{\r\n    function f() {}\r\n}\r\n\r\n/**\r\n * 块级作用域允许声明函数只有在使用大括号的情况下成立\r\n */\r\n// 不报错\r\nif (true) {\r\n    function f() {}\r\n}\r\n\r\n// 报错\r\n/*\r\nif (true)\r\n    function f() {}*/\r\n\r\n/**\r\n * 提案，未实现\r\n * 获取块级作用域结果\r\n */\r\n/*\r\nlet x = do {\r\n    let t = 1;\r\n    t * t + 1;\r\n};\r\n*/\r\n\r\n/**\r\n * const只读常量，一旦声明不能改变\r\n * @type {number}\r\n */\r\nconst PI = 3.1415;\r\n\r\n/*PI = 3;\r\nTypeError: Asignment to constant variable.*/\r\n\r\n/**\r\n * const的作用域和let命令相同，只在声明所在的块级作用域内有效\r\n */\r\n{\r\n    const MAX = 5;\r\n}\r\n\r\n/*MAX\r\nUncaught ReferenceError: MAX is not defined*/\r\n\r\n/**\r\n * 不提升，暂时性死区\r\n */\r\n/*{\r\n    console.log(MAX);//ReferenceError\r\n    const MAX = 5;\r\n}*/\r\n\r\n/**\r\n * 不可重复声明\r\n * 下面报错\r\n * @type {string}\r\n */\r\n/*var message = 'Hello';\r\nconst message = 'Goodbye';*/\r\n\r\n/**\r\n * const常量定义复合类型时指向数据所在的地址\r\n * 仅仅保证指向的地址不变，并不保证地址的数据不变\r\n * @type {Array}\r\n */\r\nconst array = [];\r\narray.push('hello');\r\narray.length = 0;\r\n//array = ['Dave'];报错\r\n\r\n/**\r\n * 冻结对象，无法添加新属性，无法获取对象属性\r\n */\r\nObject.freeze(array);\r\n\r\n/**\r\n * let\\const\\class声明的全局变量不属于顶层对象属性\r\n * @type {number}\r\n */\r\nvar b = 1;\r\nwindow.b;//1\r\n\r\nlet c = 1;\r\nwindow.c;//undefined"]}