//模块就是实现特定功能的一方法，只要把不同的函数（以及记录状态的变量）简单的放在一起，就算是一个模块

//原始写法
function m1(){
    //...
}
function m2(){
    //...
}
//上面的函数m1()和m2（），组成一个模块，使用的时候直接调用就好
//这种做法的缺点很明显，‘污染’了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接的关系

//对象写法
var module1 = new Object({
    count:0,
    m1:function(){
        //...
    },
    m2:function(){
        //...
    }
})
//上面的函数m1（）和m2（），都封装在module1对象里。使用的时候，就是调用这个对象的属性
//但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值

//立即执行函数写法
var module2 = (function(){
    var count = 0;
    var m1 = function(){
        //..
    };
    var m2 = function(){
        //...
    };
    return {
        m1:m1,
        m2:m2
    };
})();

//放大模式
//如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用‘放大模式’
var module2 = (function(mod){
    mod.m3 = function(){
        //...
    };
    return mod;
})(module2);
//上面的代码为module2模块添加一个新方法m3（），然后返回新的module2模块

//宽放大模式
//在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。
// 如果采用上面的写法，第一个执行的部分有可能加载一个不存在的空对象，这时就要采用‘宽放大模式’
var module2 = (function(mod){
    //...
    return mod;
})(module2 || {})
//与‘放大模式’相比，‘宽放大模式’就是‘立即执行函数’的参数可以是空对象

//输入全局变量
//独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
//为了在模块内部直接调用全局变量，必须显式地将其他变量 输入模块

var module3 = (function($,YAHOO){
    //...
})('jQuery','YAHOO');
//上面的module3模块需要jquery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module3.
//这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。


















